// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: collections.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addNotesToCollections = `-- name: AddNotesToCollections :exec
INSERT INTO collection_notes (collection_id, note_id, trashed)
SELECT UNNEST($1::BIGINT[]), UNNEST($2::BIGINT[]), FALSE
ON CONFLICT (collection_id, note_id)
DO UPDATE
SET trashed = FALSE
`

type AddNotesToCollectionsParams struct {
	CollectionIds []int64
	NoteIds       []int64
}

func (q *Queries) AddNotesToCollections(ctx context.Context, arg AddNotesToCollectionsParams) error {
	_, err := q.db.Exec(ctx, addNotesToCollections, arg.CollectionIds, arg.NoteIds)
	return err
}

const deleteCollection = `-- name: DeleteCollection :exec
UPDATE collection
SET deleted = $1,
    updated_by_id = $2,
    updated = $3
WHERE id = $4
  AND workspace_id = $5
`

type DeleteCollectionParams struct {
	Deleted     bool
	UpdatedByID int64
	Updated     int64
	ID          int64
	WorkspaceID int64
}

func (q *Queries) DeleteCollection(ctx context.Context, arg DeleteCollectionParams) error {
	_, err := q.db.Exec(ctx, deleteCollection,
		arg.Deleted,
		arg.UpdatedByID,
		arg.Updated,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const getCollectionByIDAndWorkspace = `-- name: GetCollectionByIDAndWorkspace :one
SELECT id, name, description, created, updated, favorite, trashed, deleted, workspace_id, created_by_id, updated_by_id
FROM collection
WHERE id = $1
  AND workspace_id = $2
`

type GetCollectionByIDAndWorkspaceParams struct {
	ID          int64
	WorkspaceID int64
}

func (q *Queries) GetCollectionByIDAndWorkspace(ctx context.Context, arg GetCollectionByIDAndWorkspaceParams) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionByIDAndWorkspace, arg.ID, arg.WorkspaceID)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
		&i.Favorite,
		&i.Trashed,
		&i.Deleted,
		&i.WorkspaceID,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const getCollectionsByNoteUUIDAndWorkspace = `-- name: GetCollectionsByNoteUUIDAndWorkspace :many

SELECT c.id, c.name, c.description, c.created, c.updated, c.favorite, c.trashed, c.deleted,
       c.workspace_id, c.created_by_id, c.updated_by_id
FROM collection c
JOIN collection_notes cn ON c.id = cn.collection_id
JOIN note n ON cn.note_id = n.id
WHERE n.uuid = $1
  AND cn.trashed = FALSE
  AND c.workspace_id = $2
  AND c.deleted = FALSE
  AND c.trashed = FALSE
  AND n.deleted = FALSE
  AND n.trashed = FALSE
ORDER BY c.updated DESC
`

type GetCollectionsByNoteUUIDAndWorkspaceParams struct {
	UUID        string
	WorkspaceID int64
}

// Avoid updating already trashed entries
func (q *Queries) GetCollectionsByNoteUUIDAndWorkspace(ctx context.Context, arg GetCollectionsByNoteUUIDAndWorkspaceParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getCollectionsByNoteUUIDAndWorkspace, arg.UUID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Created,
			&i.Updated,
			&i.Favorite,
			&i.Trashed,
			&i.Deleted,
			&i.WorkspaceID,
			&i.CreatedByID,
			&i.UpdatedByID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCollection = `-- name: InsertCollection :one
INSERT INTO collection (name, description, created, updated, favorite, trashed, deleted, workspace_id, created_by_id, updated_by_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id
`

type InsertCollectionParams struct {
	Name        string
	Description string
	Created     int64
	Updated     int64
	Favorite    bool
	Trashed     bool
	Deleted     bool
	WorkspaceID int64
	CreatedByID int64
	UpdatedByID int64
}

func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertCollection,
		arg.Name,
		arg.Description,
		arg.Created,
		arg.Updated,
		arg.Favorite,
		arg.Trashed,
		arg.Deleted,
		arg.WorkspaceID,
		arg.CreatedByID,
		arg.UpdatedByID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listCollections = `-- name: ListCollections :many
SELECT id, name, description, created, updated, favorite, trashed, deleted,
       workspace_id, created_by_id, updated_by_id
FROM collection
WHERE workspace_id = $1
  AND deleted = false
  AND trashed = false
  AND (
    -- Sort by updated timestamp
    CASE WHEN $3 = 'updated' THEN
      CASE WHEN $4 = 'desc' THEN
        CASE WHEN $5::BIGINT > 0 THEN
          (updated, id) < ($5::BIGINT, $6::BIGINT)
        ELSE TRUE END
      ELSE
        CASE WHEN $5::BIGINT > 0 THEN
          (updated, id) > ($5::BIGINT, $6::BIGINT)
        ELSE TRUE END
      END
    -- Sort by name (string)
    WHEN $3 = 'name' THEN
      CASE WHEN $4 = 'desc' THEN
        CASE WHEN $7::VARCHAR != '' THEN
          (name, id) < ($7::VARCHAR, $6::BIGINT)
        ELSE TRUE END
      ELSE
        CASE WHEN $7::VARCHAR != '' THEN
          (name, id) > ($7::VARCHAR, $6::BIGINT)
        ELSE TRUE END
      END
    ELSE TRUE
    END
  )
ORDER BY
  CASE
    WHEN $3 = 'updated' AND $4 = 'desc' THEN updated END DESC,
  CASE
    WHEN $3 = 'updated' AND $4 = 'asc' THEN updated END ASC,
  CASE
    WHEN $3 = 'name' AND $4 = 'desc' THEN name END DESC,
  CASE
    WHEN $3 = 'name' AND $4 = 'asc' THEN name END ASC,
  id DESC -- Secondary sort by ID ensures stable ordering
LIMIT $2
`

type ListCollectionsParams struct {
	WorkspaceID   int64
	Limit         int64
	SortBy        pgtype.Text
	SortOrder     pgtype.Text
	CursorUpdated int64
	CursorID      int64
	CursorName    string
}

func (q *Queries) ListCollections(ctx context.Context, arg ListCollectionsParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, listCollections,
		arg.WorkspaceID,
		arg.Limit,
		arg.SortBy,
		arg.SortOrder,
		arg.CursorUpdated,
		arg.CursorID,
		arg.CursorName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Created,
			&i.Updated,
			&i.Favorite,
			&i.Trashed,
			&i.Deleted,
			&i.WorkspaceID,
			&i.CreatedByID,
			&i.UpdatedByID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCollectionsFromNote = `-- name: RemoveCollectionsFromNote :exec

UPDATE collection_notes
SET trashed = TRUE
WHERE note_id = $1
  AND collection_id = ANY($2)
  AND trashed = FALSE
`

type RemoveCollectionsFromNoteParams struct {
	NoteID        int64
	CollectionIds []int64
}

// Avoid updating already trashed entries
func (q *Queries) RemoveCollectionsFromNote(ctx context.Context, arg RemoveCollectionsFromNoteParams) error {
	_, err := q.db.Exec(ctx, removeCollectionsFromNote, arg.NoteID, arg.CollectionIds)
	return err
}

const removeNotesFromCollection = `-- name: RemoveNotesFromCollection :exec
UPDATE collection_notes
SET trashed = TRUE
WHERE collection_id = $1
  AND note_id = ANY($2)
  AND trashed = FALSE
`

type RemoveNotesFromCollectionParams struct {
	CollectionID int64
	NoteIds      []int64
}

func (q *Queries) RemoveNotesFromCollection(ctx context.Context, arg RemoveNotesFromCollectionParams) error {
	_, err := q.db.Exec(ctx, removeNotesFromCollection, arg.CollectionID, arg.NoteIds)
	return err
}

const trashCollection = `-- name: TrashCollection :exec
UPDATE collection
SET trashed = TRUE,
    updated_by_id = $1,
    updated = $2
WHERE id = $3
  AND workspace_id = $4
`

type TrashCollectionParams struct {
	UpdatedByID int64
	Updated     int64
	ID          int64
	WorkspaceID int64
}

func (q *Queries) TrashCollection(ctx context.Context, arg TrashCollectionParams) error {
	_, err := q.db.Exec(ctx, trashCollection,
		arg.UpdatedByID,
		arg.Updated,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const trashCollectionsByIDs = `-- name: TrashCollectionsByIDs :exec
UPDATE collection
SET trashed = TRUE,
    updated_by_id = $1,
    updated = $2
WHERE id = ANY($4)
  AND workspace_id = $3
`

type TrashCollectionsByIDsParams struct {
	UpdatedByID int64
	Updated     int64
	WorkspaceID int64
	Ids         []int64
}

func (q *Queries) TrashCollectionsByIDs(ctx context.Context, arg TrashCollectionsByIDsParams) error {
	_, err := q.db.Exec(ctx, trashCollectionsByIDs,
		arg.UpdatedByID,
		arg.Updated,
		arg.WorkspaceID,
		arg.Ids,
	)
	return err
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE collection
SET name          = $1,
    description   = $2,
    favorite      = $3,
    updated_by_id = $4,
    updated       = $5
WHERE id = $6
  AND workspace_id = $7
RETURNING id, name, description, created, updated, favorite, trashed, deleted,
          workspace_id, created_by_id, updated_by_id
`

type UpdateCollectionParams struct {
	Name        string
	Description string
	Favorite    bool
	UpdatedByID int64
	Updated     int64
	ID          int64
	WorkspaceID int64
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, updateCollection,
		arg.Name,
		arg.Description,
		arg.Favorite,
		arg.UpdatedByID,
		arg.Updated,
		arg.ID,
		arg.WorkspaceID,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
		&i.Favorite,
		&i.Trashed,
		&i.Deleted,
		&i.WorkspaceID,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}
